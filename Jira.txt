# Simplifying Assumptions

    * Ticket purchases don't require payment information (payments "always succeed")
    * Little contention for tickets (no waiting room)
    * No Auth (supply your own CustomerID!)

# To Do

===>> CURRENT TASK:

[ ] Store concertSalesProjectionMediator as tables in the database via incremental (per-event) updates
    [ ] Incremental updates to concertSalesProjectionMediator as events are emitted/persisted
        [ ] Create new projector that updates only via events directly received, e.g., projector.apply(uncommittedEvents):
                ConcertSales=
                ConcertId, Artist, Date, Tickets Sold, Total Sales
            [ ] Store updated information in-memory
                [X] Scheduled -> put new value for key in map
                [X] TicketsSold -> update value with new SOLD (+= qty) and new SALES (+= paidAmount) for key in map
                [X] Rescheduled -> update value with new show date+time in map
                [X] Load the information into memory upon creation (constructor)
                    [X] implement .apply(), which applies and updates in-memory map
                    [X] in constructor, call apply() with allEvents() from the event store
                [X] Invert relationship between projector and eventStore:
                    [X] Projector registers with EventStore, which (only for in-memory projectors) immediately calls back to apply all events in the store
                [ ] In the Projector, ensure idempotency by storing the last event sequence when applying the event
                    [ ] Skip past "seen" events
                    [ ] Warn/error if we see a gap in the event sequence during apply: that means we missed something
            [X] Wire up projector so we can see it in the UI

            [X] Store updated information in the projector's own database table
                [X] As part of subscribe (aka register), ask the event store for all events since the last one we saw (uses Global Event Sequence)
                    [X] Add table for projection+last GES
                    [X] Add table for sales projection
                    [X] JDBC repository for concert_sales_projection
                    [X] JDBC repository for concertSalesProjectionMediator
                    [X] Load existing projection from database
                        [X] Add a specific query to get the GES directly as a Long instead of returning the db entity
                    [X] Detour: refactor projector into DB infra + domain projection (the apply())
                        [X] ConcertSalesProjector must be I/O-free as it is living in the Domain (or at least should be!), which means the project() method should accept and return ConcertSalesSummary object and not DB-specific ConcertSalesProjection objects
                        [X] EventStore needs allEventsAfter(globalEventSequence)
                            [X] Memory
                            [X] CSV
                            [X] JDBC
                        [X] Catch up for new Projector in ProjectionUpdater's constructor
                        [ ] ? Convert test delegation in the JdbcEventStoreTest to abstract base class?
                    [X] EventStore#save() returns last/highest/max global event sequence number as a result of the save
                    [X] EventStore#subscribe(projector, lastGES)
                    [X] Combine tests from ConcertSalesProjectorDatabaseTest into ProjectionsTest
                    [X] Update Beans and SalesController to use ConcertSalesProjectionMediator instead of ConcertSalesProjector
                    [X] Clean up any other @Deprecated methods

==> CURRENT TASK ==>
                [X] Replace "local" (per-aggregate) event sequence with the global sequence (DB/Store-generated)
                    [X] Stop using event_sequence in JDBC queries (fix tests)
                    [X] Replace client-side generated event_sequence with DB-generated BIGSERIAL
                        [X] change primary key
                [ ] Change the EventViewerController to use the correct range for selectedEvent, since they're no longer starting at 1, and _may_ have gaps
                [X] Mediator work...
                    [X] Mediator.handle(events, lastGlobalEventSequence)
                    [X] Test EventStore calls Mediator upon store.save()
                    [X] Clean up I/O-related classes from ConcertSalesProjector, e.g., it shouldn't be handed Projection (DB) objects, instead convert to ConcertSalesSummary, and it should return updated ConcertSalesSummary objects
                        [X] Rename ConcertSalesProjection to ConcertSalesSummaryDbo?
                [X] Ensure EventDto is correct in terms of EventSequence as a field, which isn't assigned until we write to the database, so the DTO can't have the sequence as part of the "payload" JSON and it should only be in the metadata for the payload.
                [ ] Scheduled -> INSERT new row in (database) table, fill sales with zeroes
                [ ] TicketsSold -> SELECT existing SOLD & SALES, then UPDATE new SOLD (+= qty) and new SALES (+= paidAmount)
                [ ] Rescheduled -> UPDATE data for ConcertId

            [ ] Convert ConcertSummaryProjector to be similar to ConcertSalesProjector
                [ ] Extract IProjector (haha) interface
                    [ ] Create base class??
                [ ] Redesign Projector startup to move retrieval of last-seen global event sequence and subscribing to the event store to Spring configuration (e.g., TixConfiguration) so that it fetches the info and subscribes the projector to the event store(s)

    [ ] Do some performance/benchmarks for 100 concerts, where each concert sells tickets to 10,000 Customers, overall generating 1MM events
    [X] Configure TestContainer tests to reuse the same container to speed up tests
    [ ] Reduce verbosity of tests by creating minimal DSL for setup AND for assertion
    [ ] Make more general way of registering projectors
        [ ] Generalize projectors to extract an interface

    [ ] ArchUnit rule to ensure that only test code calls `createForTest...` methods
    [later with modulith] Figure out listener/subscription for when events are persisted

[X] Time-travel event viewer
    [X] Show all Concerts, select a specific one to see its event stream history
        [X] In reverse chronological (event) order
    [X] Show state of the Aggregate
    [X] Show state as of a specific ("selected"?) event - defaults to most recent
        [X] Add selected event ID to the show events URL as a Query Param
        [X] Clicking on an event moves the "current" pointer to that event
        [X] Create a sublist of the events up to (and including) the selected event, then reconstitute the aggregate from the sublist
    [X] Improve layout of events in the event list

    [X] Generalize to events for any Aggregate type for a specific Agg ID
        [X] Generalize show[Concert]Events to showEvents for any type
            [X] Use functions to transform an idString to a List<Event>
            [X] Create summary projector for Customer aggregates
            [X] Use the selected projection type for selecting the functions (see comments)
            [X] Generalize the event viewer template
        [X] Create a map of projection (aggregate) type to ProjectionChoice, and pass that into the controller
        [X] Need a function that provides a list of available concertSalesProjectionMediator (aggregates) to view, i.e., generalize the listConcerts() endpoint that uses concertSummaryProjector.allConcertSummaries()
        [X] Add concrete ProjectionChoice implementations for Customer aggregate and Concert Summary projection
            [X] Wrap the Map into ProjectionChoices class
        [-] Clean up "aggregate name" to be "projection name"

[X] Convert Events from Record to Class

[X] File Persistence!
    [X] Reorganize code
        [X] move core of findById() up to Base class, relying on the eventsForAggregate method instead of directly pulling events from the map
        [X] generalize and push up eventsForAggregate
    [X] Add in file I/O for CSV event store
        [X] Create interface for reading/appending
        [X] Create file-based implementation: translate IOException to RuntimeException
            [X] Expanded CsvEventStore tests to test across ArrayList and File reader/appender implementations
        [X] Plug in file-based implementation into the CsvFileEventStore

[X] Fix up the if+instanceof to switch

[X] Database Persistence using 1 Table for all Aggregate types (vs. 1 table for each aggregate type)
    [X] SQL to create the table(s)
    [X] Docker compose config to start up local postgres container
    [X] Testcontainer setup for postgres
    [X] Create DatabaseEventStore implementation using BaseEventStore
        [X] Create static methods: forConcerts, forCustomers
        [X] Implement allEvents()
        [X] Implement eventDtosFor(ID)
        [X] Implement save(ID, Stream<EVENT>)

[ ] Variant: implement delegation (composition) oriented version of EventStore instead of subclassing?

[X] Clean up ConcertSummaryProjector (remove concertWithEventsThrough()).

[X] EventSourcedAggregate.uncommittedEvents() returns the internal mutable list! At least return a copy (preferably an unmodifiable List, or perhaps just a Stream)

[X] Check the EventDtoTest to ensure it's finding all of the concrete (record) events for the "parameterized" test

[X] Rename buy/bought to purchase/purchased

* concert.purchaseTickets() needs to generate two (3?) events
    [ ] 1. [Concert aggregate stream] TicketsSold(concertId, customerId, ...)
        [ ] (DEFER until we need it for the Concert Sales projector.)
            Implement the total paid (dollar amount) -- would be used for a projection of concert total sales
    [X] 2. [Customer aggregate stream] TicketsPurchased(customerId, concertId, ticketOrderId??...)
    ?? (don't think I need this) [Customer aggregate stream for orders] TicketsOrdered(...purchaseId)

[X] Add TicketOrderId to the TicketPurchased event (was concert.purchaseTickets() needs to return the TicketOrderId)

[X] Complete the customer purchase confirmation screen
    [X] Redirect (after POST to purchase tickets) to new endpoint:
    [X] New endpoint for /customers/{customerId}/confirmations/{ticketOrderId}
        [X] Load Customer, Load Concert => TicketOrderView
