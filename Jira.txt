# Simplifying Assumptions

    * Ticket purchases don't require payment information (payments "always succeed")
    * Little contention for tickets (no waiting room)
    * No Auth (supply your own CustomerID!)

# To Do

===>> CURRENT TASK:

[ ] Store projections as tables in the database via incremental (per-event) updates
    [ ] Incremental updates to projections as events are emitted/persisted
        [ ] Create new projector that updates only via events directly received, e.g., projector.apply(uncommittedEvents):
                ConcertSales=
                ConcertId, Artist, Date, Tickets Sold, Total Sales
            [ ] Store updated information in-memory
                [X] Scheduled -> put new value for key in map
                [X] TicketsSold -> update value with new SOLD (+= qty) and new SALES (+= paidAmount) for key in map
                [X] Rescheduled -> update value with new show date+time in map
                [X] Load the information into memory upon creation (constructor)
                    [X] implement .apply(), which applies and updates in-memory map
                    [X] in constructor, call apply() with allEvents() from the event store
                [X] Invert relationship between projector and eventStore:
                    [X] Projector registers with EventStore, which (only for in-memory projectors) immediately calls back to apply all events in the store
                [ ] In the Projector, ensure idempotency by storing the last event sequence when applying the event
                    [ ] Skip past "seen" events
                    [ ] Warn/error if we see a gap in the event sequence during apply: that means we missed something
            [X] Wire up projector so we can see it in the UI

==> NEXT TIME ==>

            [ ] Store updated information in the projector's own database table
                [ ] As part of subscribe (aka register), ask the event store for all events since the last one we saw (uses Global Event Sequence)
                    [X] Add table for projection+last GES
                    [X] Add table for sales projection
                    [ ] JDBC repository for concert_sales_projection
                    [ ] EventStore#save() returns last/highest/max global event sequence number as a result of the save
                    [ ] Projector.apply(events, lastGlobalEventSequence)
                    [ ] EventStore#subscribe(projector, lastGES)
                [ ] Scheduled -> INSERT new row in (database) table, fill sales with zeroes
                [ ] TicketsSold -> SELECT existing SOLD & SALES, then UPDATE new SOLD (+= qty) and new SALES (+= paidAmount)
                [ ] Rescheduled -> UPDATE data for ConcertId
    [ ] Reduce verbosity of tests by creating minimal DSL for setup AND for assertion
    [ ] Make more general way of registering projectors
        [ ] Generalize projectors to extract an interface

    [ ] ArchUnit rule to ensure that only test code calls `createForTest...` methods
    [later with modulith] Figure out listener/subscription for when events are persisted

[X] Time-travel event viewer
    [X] Show all Concerts, select a specific one to see its event stream history
        [X] In reverse chronological (event) order
    [X] Show state of the Aggregate
    [X] Show state as of a specific ("selected"?) event - defaults to most recent
        [X] Add selected event ID to the show events URL as a Query Param
        [X] Clicking on an event moves the "current" pointer to that event
        [X] Create a sublist of the events up to (and including) the selected event, then reconstitute the aggregate from the sublist
    [X] Improve layout of events in the event list

    [X] Generalize to events for any Aggregate type for a specific Agg ID
        [X] Generalize show[Concert]Events to showEvents for any type
            [X] Use functions to transform an idString to a List<Event>
            [X] Create summary projector for Customer aggregates
            [X] Use the selected projection type for selecting the functions (see comments)
            [X] Generalize the event viewer template
        [X] Create a map of projection (aggregate) type to ProjectionChoice, and pass that into the controller
        [X] Need a function that provides a list of available projections (aggregates) to view, i.e., generalize the listConcerts() endpoint that uses concertSummaryProjector.allConcertSummaries()
        [X] Add concrete ProjectionChoice implementations for Customer aggregate and Concert Summary projection
            [X] Wrap the Map into ProjectionChoices class
        [-] Clean up "aggregate name" to be "projection name"

[X] Convert Events from Record to Class

[X] File Persistence!
    [X] Reorganize code
        [X] move core of findById() up to Base class, relying on the eventsForAggregate method instead of directly pulling events from the map
        [X] generalize and push up eventsForAggregate
    [X] Add in file I/O for CSV event store
        [X] Create interface for reading/appending
        [X] Create file-based implementation: translate IOException to RuntimeException
            [X] Expanded CsvEventStore tests to test across ArrayList and File reader/appender implementations
        [X] Plug in file-based implementation into the CsvFileEventStore

[X] Fix up the if+instanceof to switch

[X] Database Persistence using 1 Table for all Aggregate types (vs. 1 table for each aggregate type)
    [X] SQL to create the table(s)
    [X] Docker compose config to start up local postgres container
    [X] Testcontainer setup for postgres
    [X] Create DatabaseEventStore implementation using BaseEventStore
        [X] Create static methods: forConcerts, forCustomers
        [X] Implement allEvents()
        [X] Implement eventDtosFor(ID)
        [X] Implement save(ID, Stream<EVENT>)

[ ] Variant: implement delegation (composition) oriented version of EventStore instead of subclassing?

[X] Clean up ConcertSummaryProjector (remove concertWithEventsThrough()).

[X] EventSourcedAggregate.uncommittedEvents() returns the internal mutable list! At least return a copy (preferably an unmodifiable List, or perhaps just a Stream)

[X] Check the EventDtoTest to ensure it's finding all of the concrete (record) events for the "parameterized" test

[X] Rename buy/bought to purchase/purchased

* concert.purchaseTickets() needs to generate two (3?) events
    [ ] 1. [Concert aggregate stream] TicketsSold(concertId, customerId, ...)
        [ ] (DEFER until we need it for the Concert Sales projector.)
            Implement the total paid (dollar amount) -- would be used for a projection of concert total sales
    [X] 2. [Customer aggregate stream] TicketsPurchased(customerId, concertId, ticketOrderId??...)
    ?? (don't think I need this) [Customer aggregate stream for orders] TicketsOrdered(...purchaseId)

[X] Add TicketOrderId to the TicketPurchased event (was concert.purchaseTickets() needs to return the TicketOrderId)

[X] Complete the customer purchase confirmation screen
    [X] Redirect (after POST to purchase tickets) to new endpoint:
    [X] New endpoint for /customers/{customerId}/confirmations/{ticketOrderId}
        [X] Load Customer, Load Concert => TicketOrderView
